<?php

namespace Erorus\CASC\BLTE\Chunk;

use Erorus\CASC\BLTE;
use Erorus\CASC\BLTE\Chunk;

/**
 * An encrypted chunk, hopefully via Salsa. Once decrypted, the resulting data is itself again BLTE encoded, and may be
 * compressed or plaintext.
 */
class Encrypted extends Chunk {
    /** @var string Salsa's initial constant seed, as per spec. */
    private const SALSA_CONST = 'expand 16-byte k';

    /** @var int Salsa is commonly executed 20 times per word, and Blizzard follows this spec. */
    private const SALSA_ROUNDS = 20;

    /** @var Chunk The current BLTE chunk we're writing to, after decrypting. */
    private $chainedChunk = null;

    /** @var array The current state of our hashed self::SALSA_CONST value. */
    private $constParts = [];

    /** @var string The current encryption type, as identified by Blizzard in a single byte. We only support Salsa,
     *              identified as "S".
     */
    private $encType = '';

    /** @var string The initial value (seed) which Blizzard generated when they encrypted this chunk. */
    private $iv = '';

    /** @var int The length, in bytes, of $iv. Blizzard prepends the IV with this value. */
    private $ivLength = 0;

    /** @var string|null The secret encryption key which we found by looking up $keyName. We don't always have this. */
    private $key = null;

    /** @var string The name of the key Blizzard used to encrypt this chunk. */
    private $keyName = '';

    /** @var int The length, in bytes, of $keyName. Blizzard prepends the key name with this value. */
    private $keyNameLength = 0;

    /** @var array The current state of our hashed $key value. */
    private $keyParts = [];

    /** @var string|null Salsa generates bytes by continually hashing the previous result. This is where we store that
     *                   last result for the next time we need to generate more bytes.
     */
    private $salsaIn = null;

    /** @var string Salsa prefers to generate a set amount of bytes at a time. This is a pool of generated bytes we
     *              haven't used yet, which we reserve for a later call.
     */
    private $salsaPool = '';

    /** @var string The static text we emitted to the console, so we can erase it after successful description. */
    private $statusText = '';

    /**
     * Chunk constructor. Prints decryption status text.
     *
     * @param array $chunkInfo Metadata about this chunk and the file it belongs to
     * @param resource $fileHandle Where we're writing the decoded data.
     */
    public function __construct(array $chunkInfo, $fileHandle) {
        parent::__construct($chunkInfo, $fileHandle);

        echo $this->statusText = sprintf(" -> Decrypting %d bytes in chunk %d of %d ", $this->encodedSize, $this->chunkIndex + 1, $this->chunkCount);
    }

    /**
     * Wipe the unnecessary decryption status text from the console.
     */
    public function __destruct() {
        echo sprintf('%1$s[%2$dD%3$s%1$s[%2$dD', "\e", strlen($this->statusText), str_repeat(' ', strlen($this->statusText)));
    }

    /**
     * Receives encoded bytes, decodes them, and writes them to our $fileHandle.
     *
     * @param string $buffer Encoded bytes.
     * @return int How many encoded bytes were consumed.
     */
    public function Write(string $buffer): int {
        if (!$buffer) {
            return 0;
        }
        
        $this->encodedBytesWritten += ($written = strlen($buffer));
        
        while ($buffer && !$this->encType) {
            if (!$this->keyNameLength) {
                $this->keyNameLength = current(unpack('C', substr($buffer, 0, 1)));
                $buffer = substr($buffer, 1);
                continue;
            }
            if (strlen($this->keyName) < $this->keyNameLength) {
                $length = min(strlen($buffer), $this->keyNameLength - strlen($this->keyName));
                $this->keyName .= substr($buffer, 0, $length);
                $buffer = substr($buffer, $length);
                continue;
            }

            if (!$this->ivLength) {
                $this->ivLength = current(unpack('C', substr($buffer, 0, 1)));
                $buffer = substr($buffer, 1);
                continue;
            }
            if (strlen($this->iv) < $this->ivLength) {
                $length = min(strlen($buffer), $this->ivLength - strlen($this->iv));
                $this->iv .= substr($buffer, 0, $length);
                $buffer = substr($buffer, $length);
                continue;
            }

            $this->encType = substr($buffer, 0, 1);
            $buffer = substr($buffer, 1);
        }
        if (!$this->encType) {
            return $written;
        }
        if (is_null($this->key)) {
            $this->key = BLTE::getEncryptionKey($this->keyName);
            if (!$this->key && ($this->encodedSize <= $this->encodedBytesWritten)) {
                fwrite(STDERR, sprintf("Could not find key %s\n", bin2hex($this->keyName)));
                fwrite($this->fileHandle, str_repeat("\0", $this->decodedSize));
            }
        }

        if (!$this->key) {
            return $written;
        }

        if ($this->encType !== 'S') {
            $this->key = false; // so we don't spam the error message
            fwrite(STDERR, sprintf("Unknown encryption type: %s\n", $this->encType));
            return $written;
        }

        if (is_null($this->chainedChunk)) {
            if (!$buffer) {
                return $written;
            }

            $chainedChunkType = substr($buffer, 0, 1) ^ $this->GetSalsaBytes(1);
            $buffer = substr($buffer, 1);

            $this->chainedChunk = Chunk::MakeChunk($chainedChunkType, [
                'id' => $this->chunkIndex,
                'encodedSize' => $this->decodedSize + 1,
            ], $this->fileHandle);
        }

        if ($buffer) {
            $this->chainedChunk->Write($buffer ^ $this->GetSalsaBytes(strlen($buffer)));
        }

        return $written;
    }

    /**
     * Generates and returns the next $len number of salsa bytes with our key.
     *
     * Salsa code borrowed and modified from ParagonIE_Sodium_Core_Salsa20
     *
     * @param int $len How many bytes to return.
     * @return string Salsa-generated bytes with our key.
     * @throws \Exception
     */
    private function GetSalsaBytes(int $len): string {
        $in = $this->salsaIn;
        if ($in === null) {
            // first iteration

            if (strlen($this->key) != 16) {
                throw new \Exception('Expected key length 16, received key length ' . strlen($this->key));
            }
            $this->key .= $this->key; // expand 16-byte key to 32 bytes

            $this->keyParts = unpack('V*', $this->key);
            $this->constParts = unpack('V*', static::SALSA_CONST);

            $in = str_split($this->iv);
            for ($x = 0; $x < 4; $x++) {
                $in[$x] ^= chr(($this->chunkIndex >> ($x * 8)) & 0xFF);
            }
            $in = implode('', $in);
            $in .= str_repeat("\0", 16 - strlen($in));
        }

        while (strlen($this->salsaPool) < $len) {
            $this->salsaPool .= $this->core_salsa20($in);

            $u = 1;
            // Internal counter.
            for ($i = 8; $i < 16; ++$i) {
                $u += ord($in[$i]);
                $in[$i] = chr($u & 0xff);
                $u >>= 8;
            }
        }

        $bytes = substr($this->salsaPool, 0, $len);
        $this->salsaPool = substr($this->salsaPool, $len);
        $this->salsaIn = $in;

        return $bytes;
    }

    /**
     * Given an initial seed, run it through 20 Salsa rounds and return the result.
     *
     * @param string $in
     * @return string
     */
    private function core_salsa20(string $in): string {
        $j0  = $x0  = $this->constParts[1];
        $j5  = $x5  = $this->constParts[2];
        $j10 = $x10 = $this->constParts[3];
        $j15 = $x15 = $this->constParts[4];

        $j1  = $x1  = $this->keyParts[1];
        $j2  = $x2  = $this->keyParts[2];
        $j3  = $x3  = $this->keyParts[3];
        $j4  = $x4  = $this->keyParts[4];

        $j11 = $x11 = $this->keyParts[5];
        $j12 = $x12 = $this->keyParts[6];
        $j13 = $x13 = $this->keyParts[7];
        $j14 = $x14 = $this->keyParts[8];

        $unpacked = unpack('V*', $in);
        $j6  = $x6  = $unpacked[1];
        $j7  = $x7  = $unpacked[2];
        $j8  = $x8  = $unpacked[3];
        $j9  = $x9  = $unpacked[4];

        for ($i = static::SALSA_ROUNDS; $i > 0; $i -= 2) {
            $x4 ^= 0xFFFFFFFF & ((($z = ($x0 + $x12)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x8 ^= 0xFFFFFFFF & ((($z = ($x4 + $x0)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x12 ^= 0xFFFFFFFF & ((($z = ($x8 + $x4)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x0 ^= 0xFFFFFFFF & ((($z = ($x12 + $x8)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x9 ^= 0xFFFFFFFF & ((($z = ($x5 + $x1)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x13 ^= 0xFFFFFFFF & ((($z = ($x9 + $x5)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x1 ^= 0xFFFFFFFF & ((($z = ($x13 + $x9)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x5 ^= 0xFFFFFFFF & ((($z = ($x1 + $x13)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x14 ^= 0xFFFFFFFF & ((($z = ($x10 + $x6)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x2 ^= 0xFFFFFFFF & ((($z = ($x14 + $x10)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x6 ^= 0xFFFFFFFF & ((($z = ($x2 + $x14)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x10 ^= 0xFFFFFFFF & ((($z = ($x6 + $x2)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x3 ^= 0xFFFFFFFF & ((($z = ($x15 + $x11)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x7 ^= 0xFFFFFFFF & ((($z = ($x3 + $x15)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x11 ^= 0xFFFFFFFF & ((($z = ($x7 + $x3)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x15 ^= 0xFFFFFFFF & ((($z = ($x11 + $x7)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x1 ^= 0xFFFFFFFF & ((($z = ($x0 + $x3)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x2 ^= 0xFFFFFFFF & ((($z = ($x1 + $x0)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x3 ^= 0xFFFFFFFF & ((($z = ($x2 + $x1)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x0 ^= 0xFFFFFFFF & ((($z = ($x3 + $x2)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x6 ^= 0xFFFFFFFF & ((($z = ($x5 + $x4)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x7 ^= 0xFFFFFFFF & ((($z = ($x6 + $x5)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x4 ^= 0xFFFFFFFF & ((($z = ($x7 + $x6)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x5 ^= 0xFFFFFFFF & ((($z = ($x4 + $x7)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x11 ^= 0xFFFFFFFF & ((($z = ($x10 + $x9)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x8 ^= 0xFFFFFFFF & ((($z = ($x11 + $x10)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x9 ^= 0xFFFFFFFF & ((($z = ($x8 + $x11)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x10 ^= 0xFFFFFFFF & ((($z = ($x9 + $x8)) << 18) | (($z & 0xFFFFFFFF) >> 14));

            $x12 ^= 0xFFFFFFFF & ((($z = ($x15 + $x14)) << 7) | (($z & 0xFFFFFFFF) >> 25));
            $x13 ^= 0xFFFFFFFF & ((($z = ($x12 + $x15)) << 9) | (($z & 0xFFFFFFFF) >> 23));
            $x14 ^= 0xFFFFFFFF & ((($z = ($x13 + $x12)) << 13) | (($z & 0xFFFFFFFF) >> 19));
            $x15 ^= 0xFFFFFFFF & ((($z = ($x14 + $x13)) << 18) | (($z & 0xFFFFFFFF) >> 14));
        }

        $x0  += $j0;
        $x1  += $j1;
        $x2  += $j2;
        $x3  += $j3;
        $x4  += $j4;
        $x5  += $j5;
        $x6  += $j6;
        $x7  += $j7;
        $x8  += $j8;
        $x9  += $j9;
        $x10 += $j10;
        $x11 += $j11;
        $x12 += $j12;
        $x13 += $j13;
        $x14 += $j14;
        $x15 += $j15;

        return pack('V*', $x0, $x1, $x2, $x3, $x4, $x5, $x6, $x7, $x8, $x9, $x10, $x11, $x12, $x13, $x14, $x15);
    }
}
